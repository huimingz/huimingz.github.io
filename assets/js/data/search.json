[ { "title": "在apple M1上构建x86_64 Docker镜像", "url": "/posts/docker-build-x86-image-on-apple-m1/", "categories": "docker", "tags": "docker", "date": "2022-01-06 10:00:00 +0800", "snippet": "默认通过docker build方式构建的镜像时arm64的版本，可以通过docker inspect IMAGE_ID查看到# docker image inspect 0382b9b17bdb{ ... &quot;Architecture&quot;: &quot;arm64&quot;, &quot;Variant&quot;: &quot;v8&quot;, &quot;Os&quot;: &quot;linux&quot;, &quot;Size&quot;: 223036168, &quot;VirtualSize..." }, { "title": "Golang Proxy设置", "url": "/posts/golang-goproxy/", "categories": "Golang", "tags": "Golang", "date": "2021-07-26 22:22:10 +0800", "snippet": "重置GOPROXY:go env -w GOPROXY=https://proxy.golang.org,direct" }, { "title": "IDE的那些事", "url": "/posts/IDE-Tips/", "categories": "other", "tags": "other", "date": "2021-03-08 21:34:10 +0800", "snippet": "记下那些日常使用IDE工具的坑和技巧。Goland重建缓存最近遇到了莫名爆红的情况，提示 Unresolved reference ，运行OK的。解决办法：编辑器的 File 菜单下有个 invalidate caches 选项，清除编辑器的缓存并重建项目索引。参考：Goland 提示 Unresolved reference 错误解决" }, { "title": "工具即生产力（收集）", "url": "/posts/tools-are-productivity/", "categories": "other", "tags": "other", "date": "2021-03-07 16:32:11 +0800", "snippet": "那些实用的工具们。开发GitHub Skylinehttps://skyline.github.com/GitHub 官方出品，将你过去一年的提交统计转成一个三维的直方图，并且提供 stl 文件下载，进行 3D 打印。github1shttps://github.com/conwnet/github1s只要在 GitHub 仓库域名后面加上1s，比如github1s.com/facebook/react，就能在浏览器里面使用 VS Code 环境，浏览这个仓库的代码。Swagger 文档导出https://www.docs4dev.com/tools/zh/swagger2markup/..." }, { "title": "Golang test中如何使用setUp和tearDown", "url": "/posts/golang-test-setup-and-teardown/", "categories": "Golang", "tags": "Golang", "date": "2021-02-21 09:58:00 +0800", "snippet": "在进行单元测试时，我们有些时候需要在执行前和执行后做一些工作，比如准备测试数据，测试结束后的测试数据清理。包范围的准备和清理在Golang中并没有直接提供setUp和tearDown，单我们可以利用 TestMain(m *testing.M) 来实现：package fooimport ( &quot;os&quot; &quot;testing&quot;)func TestMain(m *testing.M) { // 退出状态码 var exitCode int defer func() { os.Exit(exitCode) }() // 准备和清理工作 setUp() de..." }, { "title": "使用阿里云OSS作为图床", "url": "/posts/aliyun-oss-image-hosting-note/", "categories": "other", "tags": "other", "date": "2021-02-16 12:28:08 +0800", "snippet": "这里记录下自己使用阿里云对象存储OSS作为图床的过程。为什么选择OSS而不是使用一些公共的图床或者直接将图片保存到博客项目中？ 公共的图床虽然使用方便，不需要自己维护，但是你不能保证它不会挂掉。 将图片保存到项目中是一种不错的选择，自己维护，不用担心丢失。 使用OSS作为图床只是多一个选择，反正也不贵。我的方向：今后还是主要将图片直接放到项目中处理，部分图片放到OSS中处理，或者为了方便（文章迁移），所有的图片放到OSS中也是有可能的。准备 阿里云账号 uPic App※ 这里的uPic软件主要是为了方便在MacOS下进行图片上传处理，毕竟使用网页版文件管理和oss-brows..." }, { "title": "Golang defer知识点", "url": "/posts/golang-defer/", "categories": "Golang", "tags": "Golang", "date": "2021-02-13 16:38:42 +0800", "snippet": "defer的特性： defer在函数执行return或者panic之后执行，多个defer的执行顺序为“先进后出（FILO）”。 匿名返回值在return执行时被声明；有名返回值则是在声明的同时被声明。defer语句只能访问有名返回值，不能直接访问匿名返回值。 defer、return和返回值的执行逻辑：return先执行，return将结果写入到返回值中；然后defer开始执行一些收尾工作；最后RET（汇编命令，用于结束一个函数）携带返回值退出函数。 主动调用os.Exit(int)退出进程时，已声明的defer将不再被执行。 defer声明时会先计算确定参数的值，defer..." }, { "title": "Jekyll笔记", "url": "/posts/jekly-note/", "categories": "jeklly", "tags": "jeklly", "date": "2021-02-12 16:15:42 +0800", "snippet": "自用之前用于搭建Wordpress博客的服务器到期后，就在考虑使用Hexo或者Hugo来搭建博客。经过一番考量之后，最终选择和Jekyll。使用Jekyll的原因：有很多我喜欢的主题，托管在github，免费。环境配置先跟着官方文档一套流：http://jekyllrb-ja.github.io/使用主题为 jekyll-theme-chirpy，直接跟着文档走就完了（使用的模板项目）。写文档使用Typora或者Vim，在Typora下图片显示无解，除非使用图床，但免费图床怕哪天跪了，所以图片都放到了资源文件下（压缩后）。写完文档之后直接push到仓库，自动化构建和发布。※ 有时候会出现..." }, { "title": "Git常用命令", "url": "/posts/git-note/", "categories": "git", "tags": "git", "date": "2021-02-12 15:50:10 +0800", "snippet": "最新将博客迁移至了Jekyll，顺便也将以前整理的git命令拷贝过来。新建代码库# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url]$ git clone [url] dir配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交..." }, { "title": "领域驱动设计（笔记）", "url": "/posts/domain-deriven-desgin-note/", "categories": "architect", "tags": "architect", "date": "2021-02-12 13:34:10 +0800", "snippet": "最近读完了《领域驱动设计》，以下是个人的一些笔记和理解。首先什么是领域驱动设计，它的定义是什么？ 应该关注领域中的核心问题以及机会； 开发人员应该和领域专家一起探索模型； 开发人员应该写出能够表明模型意图的代码； 在界限上下文（bounded context）中尽量使用统一语言（ubiquitous language）。软件的核心是为用户解决领域相关问题的能力，所有的其它特性，不管多么重要，都应该服务于这个目的。大多数情况下开发人员更偏向于技术上的追求，更愿意从事精细的框架工作，企图使用技术来解决领域问题。这是一个错误的观点，开发人员同样需要面对软件的核心问题，否则只会让工作的重..." }, { "title": "计算机延迟（Latency time）", "url": "/posts/latency-time/", "categories": "facility", "tags": "facility", "date": "2021-02-11 20:17:05 +0800", "snippet": "2001 年，Peter Norvig（曾任 Google 搜索质量总监，经典教材《人工智能：一种现代方法》的作者之一）在 “ Teach Yourself Programming in Ten Years” 一文中，首次讨论了计算机领域中 memory，Cache，Disk，network 等相关延时的数据（By the way，“ Teach Yourself Programming in Ten Years”这篇文章本身也是神文，20 年过去了，依旧经典）。而让这些数字再次受关注的，是 Google 的另一位大神。2010 年，Jeff Dean 在斯坦福做了一次精彩的演讲：“B..." }, { "title": "Python类覆盖__eq__方法后的hash问题", "url": "/posts/python-eq-method-hash/", "categories": "Python", "tags": "Python", "date": "2021-02-10 18:53:05 +0800", "snippet": "为了符合对象模型，定义了自己的平等方法的类也应该定义自己的哈希方法，或者说是不可哈希方法。如果没有定义哈希方法，那么就使用超级类的哈希方法。这不太可能导致预期的行为。一个类可以通过将其 __hash__ 属性设置为 None 来使其成为不可隐藏的。在 Python 3 中，如果定义了一个类级的__eq__方法，并省略了 __hash__ 方法，那么该类就会自动标记为不可隐藏。示例在下面的例子中，Point类定义了一个__eq__方法，但没有__hash__方法。如果在这个类上调用hash方法，那么就使用为对象定义的hash方法。这不太可能给出所需的行为。PointUpdated类比较好，..." }, { "title": "GolangでUTF-8の文字列を扱う", "url": "/posts/golang-utf8-usage/", "categories": "Golang", "tags": "Golang", "date": "2021-02-10 18:50:06 +0800", "snippet": "転載元：https://qiita.com/masakielastic/items/01a4fb691c572dd71a19文字列を表示するpackage mainfunc main() { str := &quot;あいうえお&quot; buf := []byte(&quot;あいうえお&quot;) runes := []rune(&quot;あいうえお&quot;) println(str) println(string(buf)) println(string(runes))}文字列リテラルを使うpackage mainfunc main()..." }, { "title": "Python的type与object谁先存在", "url": "/posts/python-type-and-object-egg/", "categories": "Python", "tags": "Python", "date": "2021-02-10 18:50:05 +0800", "snippet": "首先理一下 type与object的关系： object是type的实例。 object没有父类，是`no object。 type是其自身的实例。 type是object 的子类。 Python中存在两种类型的objects，为了便于区分就叫他们types和non-types。non-types可以被称为实例(instances)，但这个术语也可以指类型，因为一个类型总是另一个类型的实例，types也被称之为类(classes)，我也时不时地称它们为类。基础 Python中存在两种类型的对象： Type objects，可创建实例化对象，可作为子类（met..." }, { "title": "Python继承关系时的方法装饰器与调用", "url": "/posts/python-inheritance-method-decorators-and-invocation-issue/", "categories": "Python", "tags": "Python", "date": "2021-02-10 18:50:04 +0800", "snippet": "被装饰后的类方法在子类被重写的情况思考：当父类的方法a被staticmethod装饰后，再被子类继承时会发生什么？子类需要使用装饰器么？关于装饰器实现细节，请参考: Descriptor。可以利用描述器的特性去实现自己的staticmethod等装饰器，可以参考我的实现：使用描述器实现自定义property、classmethod和staticmethodclass A: @staticmethod def say(self, name): print(f&quot;{name} A say&quot;) class B(A): # @staticm..." }, { "title": "Python列表推导式变量存储陷阱以及如何保存过程值", "url": "/posts/python-list-generator-traps-and-how-to-store-the-procedure-value/", "categories": "Python", "tags": "Python", "date": "2021-02-10 18:50:03 +0800", "snippet": "最近面试的时候遇到了这样一道面试题:funcs = [lambda x: x+n for n in range(6)]for func in funcs: print(func(3))问打印的结果是什么，当时一看到就知道这是个陷阱，也知道答案是什么，结果最后写的时候居然写错了（粗心大意）。正确的结果是：88888至于为什么结果都是一样在列表推导式的过程中n变量只有一个，而lambda表达式只是用了n变量，并没有在循环过程中保存n变量所指向的值，而n变量指向的值在这个过程中不断变化，最终是5。那么lambda表达式调用时，所有的n指向的结果是最后一个结果5。那么如何保存循环过程中的值..." }, { "title": "Python的dataclass笔记", "url": "/posts/python-dataclass-note/", "categories": "Python", "tags": "Python", "date": "2021-02-10 18:50:02 +0800", "snippet": "dataclasses模块是在3.7版本版本引入的, What’s New In Python 3.7, 相比使用传统的type创建类，dataclasses提供了一些更高效和高级的办法。dataclass的官方文档: https://docs.python.org/3/library/dataclasses.html正常定一个类:class Person(object): def __init__(self, name: str, age: int) -&amp;gt; None: self.name = name self.age = age&amp..." }, { "title": "Python并行赋值的前后顺序问题", "url": "/posts/python-parallel-assignment-order-problem/", "categories": "Python", "tags": "Python", "date": "2021-02-10 18:50:01 +0800", "snippet": "我们需要借助描述器来验证这个问题代码如下：class MyInteger(object): def __set_name__(self, owner, name): print(f&quot;__set_name__, name:{name}, owner:{owner}&quot;) self.name = name def __get__(self, instance, type_=None) -&amp;gt; object: print(f&quot;__get__, instance: {instance}, nam..." } ]
